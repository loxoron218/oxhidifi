use std::{
    error::Error,
    fmt::{Display, Formatter, Result as FmtResult},
    fs::create_dir_all,
    io::{self, Cursor, ErrorKind::Other},
    path::PathBuf,
    time::Instant,
};

use glib::user_cache_dir;
use image::{ImageError::IoError, codecs::jpeg::JpegEncoder, imageops::FilterType::Nearest};
use tokio::{fs::write, task::JoinSet};

use crate::utils::{
    image_cache::ThumbnailError::{CacheDir, Load},
    performance_monitor::get_metrics,
};

/// The standard size for thumbnail images in pixels
///
/// All thumbnails generated by this module will be resized to this dimension,
/// maintaining aspect ratio during the resizing process.
const THUMBNAIL_SIZE: i32 = 256;

/// Error types that can occur during thumbnail processing operations
///
/// This enum represents all possible errors that can occur when working
/// with thumbnail images in the cache. It provides a unified error type
/// that can be used throughout the thumbnail processing pipeline.
#[derive(Debug)]
pub enum ThumbnailError {
    /// An error occurred while creating or accessing the cache directory
    ///
    /// This variant wraps an `io::Error` that occurred during file system
    /// operations related to the cache directory.
    CacheDir(io::Error),

    /// An error occurred while loading or processing image data
    ///
    /// This variant wraps an `image::ImageError` that occurred during
    /// image loading, decoding, or encoding operations.
    Load(image::ImageError),
}

/// Implementation of Display trait for ThumbnailError
///
/// This implementation provides user-friendly error messages for all error variants.
impl Display for ThumbnailError {
    fn fmt(&self, f: &mut Formatter) -> FmtResult {
        match self {
            CacheDir(e) => write!(f, "Failed to create cache directory: {}", e),
            Load(e) => write!(f, "Failed to load image data: {}", e),
        }
    }
}

/// Implementation of Error trait for ThumbnailError
///
/// This implementation allows ThumbnailError to be used as a standard error type
/// and provides access to the underlying error source when available.
impl Error for ThumbnailError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            CacheDir(e) => Some(e),
            Load(e) => Some(e),
        }
    }
}

/// Implementation of From trait to convert io::Error to ThumbnailError
///
/// This implementation allows io::Error to be automatically converted to
/// ThumbnailError::CacheDir variant when using the ? operator.
impl From<io::Error> for ThumbnailError {
    fn from(err: io::Error) -> ThumbnailError {
        CacheDir(err)
    }
}

/// Implementation of From trait to convert ImageError to ThumbnailError
///
/// This implementation allows ImageError to be automatically converted to
/// ThumbnailError::Load variant when using the ? operator.
impl From<image::ImageError> for ThumbnailError {
    fn from(err: image::ImageError) -> ThumbnailError {
        Load(err)
    }
}

/// Returns the path to the album art cache directory, creating it if it doesn't exist.
///
/// This function determines the appropriate cache directory for album art thumbnails
/// based on the user's system configuration and creates the directory structure
/// if it doesn't already exist.
///
/// The cache directory is located at:
/// - Linux: `~/.cache/oxhidifi/covers`
/// - macOS: `~/Library/Caches/oxhidifi/covers`
/// - Windows: `%LOCALAPPDATA%\oxhidifi\covers`
///
/// # Returns
/// A `Result` containing the path to the cache directory or an `io::Error` if
/// the directory could not be created.
fn get_or_create_cache_dir() -> Result<PathBuf, io::Error> {
    let mut cache_dir = user_cache_dir();
    cache_dir.push("oxhidifi");
    cache_dir.push("covers");
    create_dir_all(&cache_dir)?;
    Ok(cache_dir)
}

/// Generates a sanitized, unique filename for a cached thumbnail based on album details.
///
/// This function creates a filesystem-safe filename by combining the album artist
/// name and album title, then sanitizing the result to remove invalid characters.
///
/// # Arguments
/// * `album_title` - The title of the album
/// * `album_artist_name` - The name of the album artist
///
/// # Returns
/// A sanitized filename with a `.jpg` extension
fn generate_cache_filename(album_title: &str, album_artist_name: &str) -> String {
    let mut name = String::with_capacity(album_artist_name.len() + album_title.len() + 1);
    name.push_str(album_artist_name);
    name.push('-');
    name.push_str(album_title);

    // Sanitize the filename to remove characters that are invalid on most filesystems.
    let sanitized: String = name
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '-' || *c == '_')
        .collect();
    format!("{}.jpg", sanitized)
}

/// Optimized version of get_or_create_thumbnail with better caching and adaptive resizing
///
/// This function creates a thumbnail from image data and caches it for future use.
/// If a thumbnail already exists for the given album, it returns the existing path
/// without reprocessing the image.
///
/// The function uses optimized image processing techniques:
/// - Nearest neighbor filtering for fast resizing
/// - JPEG compression with quality 70 for smaller file sizes
/// - Asynchronous file I/O for better performance
///
/// # Arguments
/// * `image_data` - The raw image data to process
/// * `album_title` - The title of the album (used for filename generation)
/// * `album_artist_name` - The name of the album artist (used for filename generation)
///
/// # Returns
/// A `Result` containing the path to the cached thumbnail or a `ThumbnailError` if
/// processing failed.
pub async fn get_or_create_thumbnail_optimized(
    image_data: &[u8],
    album_title: &str,
    album_artist_name: &str,
) -> Result<PathBuf, ThumbnailError> {
    let start_time = Instant::now();
    let cache_dir = get_or_create_cache_dir()?;
    let filename = generate_cache_filename(album_title, album_artist_name);
    let cache_path = cache_dir.join(filename);

    // If the thumbnail already exists, no need to process it again.
    if cache_path.exists() {
        get_metrics().record_cache_hit();
        return Ok(cache_path);
    }
    get_metrics().record_cache_miss();

    // Use faster filtering for better performance
    let target_size = THUMBNAIL_SIZE as u32;

    // Use Nearest filter which is fastest, even for larger images
    let filter_type = Nearest;
    let img = image::load_from_memory(image_data)?;
    let scaled_img = img.resize(target_size, target_size, filter_type);
    let rgb_img = scaled_img.to_rgb8();

    // Use lower quality JPEG compression for faster processing
    let mut buffer: Vec<u8> = Vec::new();
    let mut cursor = Cursor::new(&mut buffer);
    let jpeg_encoder = JpegEncoder::new_with_quality(&mut cursor, 70);
    rgb_img.write_with_encoder(jpeg_encoder)?;

    // The file I/O part is asynchronous using tokio.
    write(&cache_path, &buffer).await?;

    // Record processing time
    get_metrics().record_image_processing_time(start_time.elapsed());
    Ok(cache_path)
}

/// Processes multiple images concurrently and returns their cache paths
///
/// This function takes a vector of image data with associated album information
/// and processes them concurrently using tokio tasks. Each image is processed
/// in parallel, which significantly improves performance when processing
/// many album covers.
///
/// # Arguments
/// * `images` - A vector of tuples containing (image_data, album_title, album_artist_name)
///
/// # Returns
/// A vector of Results containing the cache paths or errors for each image
pub async fn process_images_concurrently(
    images: Vec<(Vec<u8>, String, String)>,
) -> Vec<Result<PathBuf, ThumbnailError>> {
    let start_time = Instant::now();

    // Process images in smaller concurrent batches to avoid overwhelming the system
    const CONCURRENT_LIMIT: usize = 10;

    // If there are no images to process, return an empty vector
    if images.is_empty() {
        return Vec::new();
    }
    // Process images concurrently with a concurrency limit using JoinSet
    let mut join_set = JoinSet::new();
    let mut active_tasks = 0;
    let mut results = Vec::with_capacity(images.len());
    let mut image_iter = images.into_iter();

    // Process images with a concurrency limit
    loop {
        // Add tasks up to the concurrency limit
        while active_tasks < CONCURRENT_LIMIT {
            if let Some((image_data, album_title, album_artist_name)) = image_iter.next() {
                join_set.spawn(async move {
                    get_or_create_thumbnail_optimized(&image_data, &album_title, &album_artist_name)
                        .await
                });
                active_tasks += 1;
            } else {
                break;
            }
        }

        // If no more tasks to add, break
        if active_tasks == 0 {
            break;
        }

        // Wait for a task to complete
        if let Some(result) = join_set.join_next().await {
            match result {
                Ok(task_result) => results.push(task_result),
                Err(e) => {
                    eprintln!("Image processing task failed: {:?}", e);
                    results.push(Err(ThumbnailError::Load(IoError(io::Error::new(
                        Other,
                        "Task join error",
                    )))));
                }
            }
            active_tasks -= 1;
        } else {
            // No more tasks in the set
            break;
        }
    }

    // Record processing time
    get_metrics().record_image_processing_time(start_time.elapsed());

    // All results are already in the correct format, so we can return them directly
    results
}
